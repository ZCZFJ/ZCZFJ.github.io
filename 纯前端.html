<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- WARNING: API Key is exposed in this file! Do not deploy publicly! -->
    <title>(合并版 v7.0 - 纯前端) - 修改版</title>
    <!-- CDN 引入 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- MathJax -->
    <script>
        MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$', '$$'], ['\\[', '\\]']] },
            svg: { fontCache: 'global' },
            options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        :root {
            --ease-out-quint: cubic-bezier(0.22, 1, 0.36, 1);
            --ease-in-out-back: cubic-bezier(0.68, -0.55, 0.27, 1.55);
            --ease-bounce: cubic-bezier(0.18, 0.89, 0.32, 1.28);
            --blue-glow-color: rgba(59, 130, 246, 0.5); /* Tailwind blue-500 */
            --red-glow-color: rgba(239, 68, 68, 0.5); /* Tailwind red-500 */
            --mouse-x: 50%; /* Default mouse position for shine */
            --mouse-y: 50%;
        }

        /* 全局字体大小调整控制 */
        body {
            -webkit-text-size-adjust: 100%;
            text-size-adjust: 100%;
        }

        /* Enhanced Button Styles */
        .interactive-button {
            position: relative;
            overflow: hidden;
            transition: transform 0.2s var(--ease-out-quint), box-shadow 0.2s var(--ease-out-quint);
            z-index: 1;
        }
        .interactive-button:hover {
            transform: scale(1.05);
            z-index: 2;
        }
        .interactive-button::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle at var(--mouse-x) var(--mouse-y), rgba(255, 255, 255, 0.3) 0%, rgba(255, 255, 255, 0) 60%);
            border-radius: inherit;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 1;
        }
        .interactive-button:hover::before {
            opacity: 1;
        }
        #newChatBtn:hover {
            box-shadow: 0 0 15px 3px var(--blue-glow-color);
        }
        #sendButton:hover:not(:disabled) {
             box-shadow: 0 0 15px 3px var(--blue-glow-color);
        }
        .delete-chat-btn {
            transform: translateY(-50%);
        }
        .delete-chat-btn:hover {
             box-shadow: 0 0 10px 2px var(--red-glow-color);
             transform: translateY(calc(-50% - 3px)) scale(1.1);
        }
        .interactive-button > * {
            position: relative;
            z-index: 2;
        }

        /* Input Capsule Styles */
        #inputCapsule {
            transform: scale(1);
            z-index: 10;
        }
        #inputCapsule:hover,
        #inputCapsule:focus-within {
            transform: scale(1.01);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        /* Input field style fix */
        #messageInput {
             background-color: transparent !important;
             border: none !important;
             appearance: none;
             -webkit-appearance: none;
             -moz-appearance: none;
             outline: none;
             box-shadow: none;
        }

        /* Style for mobile menu button */
        #mobileMenuBtn {
             background-color: rgba(255, 255, 255, 0.75);
             backdrop-filter: blur(4px);
             -webkit-backdrop-filter: blur(4px);
        }

        /* Modal Animation */
        .modal-entering #confirmContent { animation: modalEnterAnimation 0.4s var(--ease-out-quint) forwards; }
        .confirm-leave-active #confirmContent { animation: confirmLeave 0.2s var(--ease-out-quint) forwards; }
        @keyframes confirmLeave { from { opacity: 1; transform: translate(-50%, -50%) scale(1); } to { opacity: 0; transform: translate(-50%, -55%) scale(0.98); } }
        @keyframes modalEnterAnimation { 0% { opacity: 0; transform: translate(-50%, -40%) rotate(-5deg) scale(0.9); } 100% { opacity: 1; transform: translate(-50%, -50%) rotate(0deg) scale(1); } }

        /* Touch Optimization (Delete Btn) */
        @media (max-width: 767px) {
            .chat-list-item .delete-chat-btn { opacity: 1 !important; color: theme('colors.gray.400'); }
            .chat-list-item .delete-chat-btn:hover,
            .chat-list-item .delete-chat-btn:active { color: theme('colors.red.500'); background-color: theme('colors.red.100'); box-shadow: 0 0 10px 2px var(--red-glow-color); transform: translateY(calc(-50% - 3px)) scale(1.1); }
            #inputCapsule { max-width: none !important; margin-left: 0 !important; margin-right: 0 !important; }
        }

        /* Other Base Styles */
        .sidebar-mobile { transform: translateX(-100%); transition: transform 0.4s var(--ease-out-quint); }
        .sidebar-visible { transform: translateX(0); }
        .mobile-menu-btn { transition: opacity 0.2s var(--ease-out-quint), transform 0.2s var(--ease-out-quint); transform: translateX(0); opacity: 1; }
        .btn-hidden { opacity: 0; transform: translateX(-20px); pointer-events: none; }
        .notification-container.active { opacity: 1; transform: translateY(0); pointer-events: auto; transition: opacity 0.3s ease, transform 0.3s ease; }
        .notification-container { opacity: 0; transform: translateY(20px); pointer-events: none; transition: opacity 0.3s ease, transform 0.3s ease; }
        .notification-bubble { animation: notificationFloat 3s var(--ease-in-out-back) infinite; }
        @keyframes notificationFloat { 0%, 100% { transform: translate(-50%, -2px); } 50% { transform: translate(-50%, 2px); } }
        .message-enter { animation: messageFadeIn 0.3s var(--ease-bounce); }
        @keyframes messageFadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .typing-loader div { animation: dotsPulse 1.4s infinite ease-in-out; }
        @keyframes dotsPulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.2); opacity: 0.5; } }
        .message-bubble { max-width: min(85%, 600px); border-radius: 18px; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word; transition: all 0.3s ease-in-out; min-height: 2.5rem; display: flex; align-items: center; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        .user-bubble { background-color: #0b93f6; color: white; border-bottom-right-radius: 4px; }
        .assistant-bubble { background-color: #e5e5ea; color: #000; border-bottom-left-radius: 4px; }
        .message-content, .user-bubble .message-content { padding: 0.75rem; width: 100%; min-height: inherit; display: flex; flex-direction: column; }
        .typing-loader-container { padding: 0.75rem; width: 100%; display: flex; align-items: center; justify-content: center; }
        .assistant-bubble pre { background-color: #1e1e1e; color: #d4d4d4; padding: 1em; border-radius: 8px; overflow-x: auto; margin-top: 0.5em; margin-bottom: 0.5em; width: 100%; max-width: 100%; min-height: initial; align-items: initial; border: 1px solid #3a3a3a; word-break: normal; overflow-wrap: normal; }
        .assistant-bubble pre code { background: none; padding: 0; white-space: pre; word-wrap: normal; overflow-wrap: normal; display: block; }
        .assistant-bubble code:not(pre > code) { background-color: rgba(0, 0, 0, 0.08); padding: 0.2em 0.4em; border-radius: 4px; font-size: 0.9em; border: 1px solid rgba(0,0,0,0.05); word-break: break-all; }
        .assistant-bubble a { color: #007AFF; text-decoration: underline; }
        .assistant-bubble ul, .assistant-bubble ol { padding-left: 1.5em; margin-top: 0.5em; margin-bottom: 0.5em; width: 100%; min-height: initial; align-items: initial; }
        .assistant-bubble li { margin-bottom: 0.25em; }
        .assistant-bubble mjx-container { width: 100%; max-width: 100%; overflow-x: auto; overflow-y: hidden; min-height: initial; align-items: initial; padding: 5px 0; display: block; }
        .main-content { transition: margin-left 0.4s var(--ease-out-quint); }

        @media (min-width: 768px) {
            .md\:ml-72 { margin-left: 0rem !important; }
            .sidebar-mobile { transform: none !important; }
            .mobile-menu-btn { display: none !important; }
        }

        /* Explicit Tailwind class definitions */
        .backdrop-blur-sm { --tw-backdrop-blur: blur(4px); backdrop-filter: var(--tw-backdrop-filter); -webkit-backdrop-filter: var(--tw-backdrop-filter); }
        .backdrop-blur-md { --tw-backdrop-blur: blur(8px); backdrop-filter: var(--tw-backdrop-filter); -webkit-backdrop-filter: var(--tw-backdrop-filter); }
        .backdrop-blur-lg { --tw-backdrop-blur: blur(16px); backdrop-filter: var(--tw-backdrop-filter); -webkit-backdrop-filter: var(--tw-backdrop-filter); }
        .bg-white\/20 { background-color: rgba(255, 255, 255, 0.2); }
        .bg-white\/30 { background-color: rgba(255, 255, 255, 0.3); }
        .bg-white\/50 { background-color: rgba(255, 255, 255, 0.5); }
        .bg-white\/75 { background-color: rgba(255, 255, 255, 0.75); }
        :root {
            --tw-backdrop-blur: ; --tw-backdrop-brightness: ; --tw-backdrop-contrast: ; --tw-backdrop-grayscale: ; --tw-backdrop-hue-rotate: ; --tw-backdrop-invert: ; --tw-backdrop-opacity: ; --tw-backdrop-saturate: ; --tw-backdrop-sepia: ;
            --tw-backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);
        }
        .bg-transparent { background-color: transparent; }
        .border-none { border: none; }

    </style>
</head>
<body class="bg-gray-50 h-screen flex antialiased text-gray-800 overflow-hidden">

    <!-- Notification Container -->
    <div id="notificationContainer" class="notification-container fixed bottom-20 left-1/2 transform -translate-x-1/2 z-50">
        <div id="notificationBubble" class="notification-bubble px-6 py-3 bg-black/80 text-white rounded-full text-sm shadow-lg"></div>
    </div>

    <!-- Confirm Modal -->
    <div id="confirmModal" class="fixed inset-0 z-[60] hidden p-4">
        <div class="absolute inset-0 bg-black/30" id="confirmBackdrop"></div>
        <div class="absolute top-1/2 left-1/2 bg-white rounded-2xl shadow-xl p-6 min-w-[300px] max-w-md w-full" id="confirmContent">
            <div class="text-lg font-semibold mb-3" id="confirmTitle">确认操作</div>
            <div class="text-gray-600 mb-6" id="confirmMessage">你确定要执行此操作吗？</div>
            <div class="flex justify-end gap-3">
                <button id="confirmCancel" class="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-gray-300">取消</button>
                <button id="confirmOk" class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors focus:outline-none focus:ring-2 focus:ring-red-300 interactive-button">
                    <span id="confirmOkText">确认</span>
                 </button>
            </div>
        </div>
    </div>

    <!-- Mobile Menu Button -->
    <button class="mobile-menu-btn fixed top-4 left-4 z-50 p-2 bg-white/80 backdrop-blur-md shadow-lg rounded-full md:hidden focus:outline-none focus:ring-2 focus:ring-blue-500 interactive-button" id="mobileMenuBtn" aria-label="切换菜单">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7" /></svg>
    </button>

    <!-- Main Container -->
    <div class="flex h-full w-full">
        <!-- Sidebar -->
        <div id="sidebar" class="sidebar-mobile w-72 bg-white border-r flex flex-col fixed md:static h-full z-40 shrink-0">
            <!-- Sidebar Header -->
            <div class="p-4 border-b flex items-center justify-between shrink-0">
                <button id="newChatBtn" class="flex items-center gap-2 bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-all focus:outline-none focus:ring-2 focus:ring-blue-300 interactive-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clip-rule="evenodd" /></svg>
                    <span>新对话</span>
                </button>
                <button id="closeSidebarBtn" class="md:hidden p-2 text-gray-500 hover:bg-gray-100 rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-gray-300 interactive-button" aria-label="关闭菜单">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>
                </button>
            </div>
            <!-- Chat List (Scrollable) -->
            <div id="chatList" class="flex-1 overflow-y-auto p-2 space-y-1">
                <div class="text-center text-gray-400 py-4">加载中...</div>
            </div>
        </div>

        <!-- Main Chat Area -->
        <div id="mainContent" class="main-content flex-1 flex flex-col h-full bg-gray-100 md:ml-72">
             <!-- Messages Area (Scrollable) -->
            <div id="chatMessages" class="flex-1 overflow-y-auto p-4 space-y-4 scroll-smooth">
                <div id="initialMessage" class="text-center text-gray-400 py-8">开始新的对话吧！</div>
            </div>

            <!-- Floating Input Area -->
            <div class="sticky bottom-0 px-3 md:px-4 pb-3 md:pb-4 shrink-0 bg-transparent">
                <div id="inputCapsule"
                     class="relative flex items-center rounded-full shadow-lg p-1.5 md:p-2 w-full md:max-w-2xl md:mx-auto
                            bg-white/20 backdrop-blur-lg border border-white/10
                            transition-all duration-300 hover:bg-white/30">
                    <form id="chatForm" class="flex-1 flex gap-2 md:gap-3 items-center">
                        <input type="text" id="messageInput"
                               class="flex-1 p-2 md:p-3 bg-transparent border-none rounded-full
                                      focus:outline-none focus:ring-0 text-gray-800 placeholder-gray-500/80"
                               placeholder="输入消息..." autocomplete="off" required>
                        <button type="submit" id="sendButton"
                                class="w-10 h-10 md:w-12 md:h-12 bg-blue-600/90 text-white rounded-full
                                       hover:bg-blue-700/90 transition-all flex items-center justify-center
                                       focus:outline-none focus:ring-2 focus:ring-blue-300 disabled:bg-blue-300
                                       disabled:opacity-60 shrink-0 interactive-button backdrop-blur-md"
                                aria-label="发送消息">
                            <svg xmlns="http://www.w3.org/2000/svg"
                                 class="h-5 w-5 md:h-6"
                                 viewBox="0 0 20 20"
                                 fill="currentColor">
                                <path fill-rule="evenodd"
                                      d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 1.414L10.586 9H7a1 1 0 100 2h3.586l-1.293 1.293a1 1 0 101.414 1.414l3-3a1 1 0 000-1.414z"
                                      clip-rule="evenodd"></path>
                            </svg>
                       </button>
                    </form>
                </div>
            </div>
        </div>
    </div>

<script>
    // --- Constants and Config ---
    // !!!!! WARNING: API KEY EXPOSED IN CLIENT-SIDE CODE !!!!!
    // !!!!! THIS IS VERY INSECURE FOR PUBLIC DEPLOYMENT !!!!!
    const DEEPSEEK_API_KEY = 'sk-80fe3eccdc134d8986a3a6f6bef83248'; // Replace with your actual key
    const DEEPSEEK_API_URL = 'https://api.deepseek.com/v1/chat/completions';
    const LOCALSTORAGE_KEY = 'chatAppData_v1';

    // --- Marked & Highlight.js Config ---
    marked.setOptions({
        highlight: function(code, lang) {
            const language = hljs.getLanguage(lang) ? lang : 'plaintext';
            const escapeHtml = (unsafe) => {
                return unsafe
                        .replace(/&/g, "&amp;")
                        .replace(/</g, "&lt;")
                        .replace(/>/g, "&gt;")
                        .replace(/"/g, "&quot;")
                        .replace(/'/g, "&#39;");
                };

            if (language === 'plaintext' && lang && lang !== 'plaintext' && lang !== 'mermaid') {
                const escapedCode = escapeHtml(code);
                return `<code class="hljs language-${language}">${escapedCode}</code>`;
            }
            try {
                return hljs.highlight(code, { language, ignoreIllegals: true }).value;
            } catch (e) {
                console.error("Highlight.js error:", e, "Language:", lang, "Code snippet:", code.substring(0, 100));
                const escapedCode = escapeHtml(code);
                return `<code class="hljs language-plaintext">${escapedCode}</code>`;
            }
        },
        langPrefix: 'hljs language-',
        gfm: true,
        breaks: true,
    });

    // --- Global State ---
    let currentSessionId = null;
    let isStreaming = false;
    let isSidebarAnimating = false;
    let notificationTimeoutId = null;
    let appData = { sessions: {} }; // In-memory representation of localStorage data

    // --- DOM Elements ---
    const sidebar = document.getElementById('sidebar');
    const mobileMenuBtn = document.getElementById('mobileMenuBtn');
    const closeSidebarBtn = document.getElementById('closeSidebarBtn');
    const newChatBtn = document.getElementById('newChatBtn');
    const chatListContainer = document.getElementById('chatList');
    const chatMessagesContainer = document.getElementById('chatMessages');
    const initialMessage = document.getElementById('initialMessage');
    const chatForm = document.getElementById('chatForm');
    const messageInput = document.getElementById('messageInput');
    const sendButton = document.getElementById('sendButton');
    const mainContent = document.getElementById('mainContent');
    const notificationContainer = document.getElementById('notificationContainer');
    const notificationBubble = document.getElementById('notificationBubble');
    const confirmModal = document.getElementById('confirmModal');
    const inputCapsule = document.getElementById('inputCapsule');

    // --- localStorage Data Management ---
    function loadDataFromLocalStorage() {
        try {
            const storedData = localStorage.getItem(LOCALSTORAGE_KEY);
            if (storedData) {
                appData = JSON.parse(storedData);
                // Basic validation/migration if needed in the future
                if (!appData.sessions) appData.sessions = {};
                console.log("Loaded data from localStorage:", Object.keys(appData.sessions).length, "sessions");
            } else {
                console.log("No data found in localStorage, initializing.");
                appData = { sessions: {} };
                saveDataToLocalStorage(); // Save initial structure
            }
        } catch (error) {
            console.error("Error loading data from localStorage:", error);
            appData = { sessions: {} }; // Reset on error
            showNotification("加载本地数据出错，部分记录可能丢失", 5000);
        }
        // Clean up old sessions (older than 10 days)
        const now = Math.floor(Date.now() / 1000);
        const tenDaysAgo = now - (86400 * 10);
        let cleanedCount = 0;
        Object.keys(appData.sessions).forEach(sessionId => {
            if (appData.sessions[sessionId].last_accessed_at < tenDaysAgo) {
                delete appData.sessions[sessionId];
                cleanedCount++;
            }
        });
        if (cleanedCount > 0) {
            console.log(`Cleaned up ${cleanedCount} old sessions.`);
            saveDataToLocalStorage();
        }
    }

    function saveDataToLocalStorage() {
        try {
            localStorage.setItem(LOCALSTORAGE_KEY, JSON.stringify(appData));
            // console.log("Saved data to localStorage."); // Can be noisy
        } catch (error) {
            console.error("Error saving data to localStorage:", error);
            showNotification("保存聊天记录到本地失败", 5000);
        }
    }

    // Generate UUID (simple version)
    function generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    // --- Sidebar Control (No change needed) ---
    const openSidebar = () => { /* ... same as before ... */ if (isSidebarAnimating || sidebar.classList.contains('sidebar-visible')) return; if (window.innerWidth >= 768) return; isSidebarAnimating = true; sidebar.classList.add('sidebar-visible'); mobileMenuBtn.classList.add('btn-hidden'); sidebar.addEventListener('transitionend', () => { isSidebarAnimating = false; }, { once: true }); setTimeout(() => { isSidebarAnimating = false; }, 500); };
    const closeSidebar = () => { /* ... same as before ... */ if (isSidebarAnimating || !sidebar.classList.contains('sidebar-visible')) return; if (window.innerWidth >= 768) return; isSidebarAnimating = true; sidebar.classList.remove('sidebar-visible'); mobileMenuBtn.classList.remove('btn-hidden'); sidebar.addEventListener('transitionend', () => { isSidebarAnimating = false; }, { once: true }); setTimeout(() => { isSidebarAnimating = false; }, 500); };
    const toggleSidebar = () => { /* ... same as before ... */ if (window.innerWidth < 768) { sidebar.classList.contains('sidebar-visible') ? closeSidebar() : openSidebar(); } };

    // --- Notifications (No change needed) ---
    function showNotification(text, duration = 3000) { /* ... same as before ... */ console.log("Notification:", text); if (notificationTimeoutId) clearTimeout(notificationTimeoutId); notificationBubble.textContent = text; notificationContainer.classList.add('active'); notificationTimeoutId = setTimeout(() => { notificationContainer.classList.remove('active'); notificationTimeoutId = null; }, duration); }

    // --- Confirm Modal (No change needed) ---
    function showConfirm(title = '确认操作', message = '你确定要执行此操作吗？', confirmText = '确认', cancelText = '取消') { /* ... same as before ... */ return new Promise(resolve => { const currentModal = document.getElementById('confirmModal'); const currentBackdrop = document.getElementById('confirmBackdrop'); const currentContent = document.getElementById('confirmContent'); const currentTitle = document.getElementById('confirmTitle'); const currentMessage = document.getElementById('confirmMessage'); let currentOkBtn = document.getElementById('confirmOk'); let currentCancelBtn = document.getElementById('confirmCancel'); let currentOkText = document.getElementById('confirmOkText'); currentTitle.textContent = title; currentMessage.textContent = message; const newOkBtn = currentOkBtn.cloneNode(true); currentOkBtn.parentNode.replaceChild(newOkBtn, currentOkBtn); currentOkBtn = newOkBtn; currentOkText = currentOkBtn.querySelector('span'); if (currentOkText) currentOkText.textContent = confirmText; currentOkBtn.addEventListener('mousemove', handleButtonMouseMove); const newCancelBtn = currentCancelBtn.cloneNode(true); currentCancelBtn.parentNode.replaceChild(newCancelBtn, currentCancelBtn); currentCancelBtn = newCancelBtn; currentCancelBtn.textContent = cancelText; const newBackdrop = currentBackdrop.cloneNode(true); currentBackdrop.parentNode.replaceChild(newBackdrop, currentBackdrop); const currentClonedBackdrop = newBackdrop; currentModal.classList.remove('hidden'); currentModal.classList.add('flex'); currentModal.classList.remove('confirm-leave-active'); currentModal.classList.add('modal-entering'); let resolved = false; const close = (result) => { if (resolved) return; resolved = true; currentModal.classList.remove('modal-entering'); currentModal.classList.add('confirm-leave-active'); const onAnimationEnd = (e) => { if (e.target === currentContent && resolved && currentModal.classList.contains('confirm-leave-active')) { currentModal.classList.add('hidden'); currentModal.classList.remove('flex', 'confirm-leave-active'); currentContent.removeEventListener('animationend', onAnimationEnd); resolve(result); } }; currentContent.addEventListener('animationend', onAnimationEnd); setTimeout(() => { if (!currentModal.classList.contains('hidden') && resolved) { console.warn("Confirm modal close fallback timeout triggered."); currentModal.classList.add('hidden'); currentModal.classList.remove('flex', 'confirm-leave-active'); currentContent.removeEventListener('animationend', onAnimationEnd); resolve(result); } }, 350); }; currentOkBtn.addEventListener('click', () => close(true), { once: true }); currentCancelBtn.addEventListener('click', () => close(false), { once: true }); currentClonedBackdrop.addEventListener('click', () => close(false), { once: true }); }); }

    // --- Message Rendering (No change needed, but ensure MathJax call is robust) ---
    const renderMessage = (role, content, isLoading = false) => { /* ... same as before ... */ initialMessage.classList.add('hidden'); const isUser = role === 'user'; const bubbleWrapper = document.createElement('div'); bubbleWrapper.className = `message-enter flex ${isUser ? 'justify-end' : 'justify-start'} mb-4`; const bubbleContent = document.createElement('div'); bubbleContent.className = `message-bubble ${isUser ? 'user-bubble' : 'assistant-bubble'}`; if (isLoading) { bubbleContent.innerHTML = `<div class="typing-loader-container"><div class="typing-loader flex gap-1.5"><div class="w-2 h-2 bg-gray-500 rounded-full" style="animation-delay: 0s;"></div><div class="w-2 h-2 bg-gray-500 rounded-full" style="animation-delay: 0.2s;"></div><div class="w-2 h-2 bg-gray-500 rounded-full" style="animation-delay: 0.4s;"></div></div></div>`; bubbleWrapper.dataset.loadingId = 'assistant-loading'; } else { const parsedContent = marked.parse(content || ''); const innerDiv = document.createElement('div'); innerDiv.className = `message-content ${isUser ? 'user-content' : 'assistant-content'}`; innerDiv.innerHTML = parsedContent; bubbleContent.appendChild(innerDiv); if (role === 'assistant' && content && content.match(/(\$|\\\(|\\\[|\\begin\{)/)) { requestAnimationFrame(() => { if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) { MathJax.typesetPromise([innerDiv]).catch(err => console.error('MathJax typeset failed:', err)); } }); } } bubbleWrapper.appendChild(bubbleContent); chatMessagesContainer.appendChild(bubbleWrapper); requestAnimationFrame(() => chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'smooth' })); return bubbleWrapper; };
    const updateLoadingMessage = (content) => { /* ... same as before ... */ const loadingBubbleWrapper = chatMessagesContainer.querySelector('[data-loading-id="assistant-loading"]'); if (loadingBubbleWrapper) { const bubbleContent = loadingBubbleWrapper.querySelector('.message-bubble'); if (bubbleContent) { const parsedContent = marked.parse(content || ''); let innerDiv = bubbleContent.querySelector('.message-content'); if (!innerDiv) { bubbleContent.innerHTML = ''; innerDiv = document.createElement('div'); innerDiv.className = 'message-content assistant-content'; bubbleContent.appendChild(innerDiv); } innerDiv.innerHTML = parsedContent; if (content && content.match(/(\$|\\\(|\\\[|\\begin\{)/)) { requestAnimationFrame(() => { if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) { MathJax.typesetPromise([innerDiv]).catch(err => console.error('MathJax stream update failed:', err)); } }); } const isScrolledToBottom = chatMessagesContainer.scrollHeight - chatMessagesContainer.clientHeight <= chatMessagesContainer.scrollTop + 100; if (isScrolledToBottom) { requestAnimationFrame(() => chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'smooth' })); } return loadingBubbleWrapper; } } return null; };
    const removeLoadingIndicator = () => { /* ... same as before ... */ const loadingBubbleWrapper = chatMessagesContainer.querySelector('[data-loading-id="assistant-loading"]'); if (loadingBubbleWrapper) { const innerContent = loadingBubbleWrapper.querySelector('.message-content'); if (!innerContent || (innerContent.innerHTML.trim().length === 0 && innerContent.textContent.trim().length === 0)) { loadingBubbleWrapper.remove(); } else { delete loadingBubbleWrapper.dataset.loadingId; } } if (chatMessagesContainer.children.length === 0 && !chatMessagesContainer.querySelector('[data-loading-id="assistant-loading"]')) { initialMessage.classList.remove('hidden'); } };

    // --- Client-Side Logic (Replaces API Interaction) ---
    const loadChatList = () => { // Changed: Reads from appData
        console.log("Loading chat list from localStorage...");
        chatListContainer.innerHTML = ''; // Clear loading message immediately

        // Get sessions from appData and convert to array
        const sessionsArray = Object.entries(appData.sessions).map(([id, sessionData]) => ({
            id: id,
            ...sessionData
        }));

        // Sort by last accessed time, descending
        sessionsArray.sort((a, b) => (b.last_accessed_at || 0) - (a.last_accessed_at || 0));

        if (sessionsArray.length === 0) {
            chatListContainer.innerHTML = '<div class="text-center text-gray-400 py-4">暂无对话</div>';
            console.log("No chats found in localStorage.");
            return sessionsArray; // Return empty array
        }

        console.log(`Found ${sessionsArray.length} chats in localStorage.`);
        renderChatList(sessionsArray); // Render using the sorted array
        return sessionsArray; // Return the sorted array
    };

    const renderChatList = (chatsToRender) => { // Renamed from renderChatListFromCache
         console.log("Rendering chat list...");
         chatListContainer.innerHTML = ''; // Ensure it's clear before rendering

         chatsToRender.forEach(chat => {
             const chatItem = document.createElement('div');
             const isActive = currentSessionId === chat.id;
             chatItem.className = `chat-list-item group relative p-3 rounded-lg cursor-pointer transition-colors ${isActive ? 'bg-blue-50 hover:bg-blue-100' : 'hover:bg-gray-100'}`;
             chatItem.dataset.sessionId = chat.id;

             // Calculate title (same logic as backend)
             const messages = chat.messages || [];
             let title = '新对话'; // Default title
             const firstUserMessage = messages.find(msg => msg.role === 'user');
             if (firstUserMessage && firstUserMessage.content) {
                 title = firstUserMessage.content.substring(0, 20) + (firstUserMessage.content.length > 20 ? '...' : '');
             }

             const lastAccessedDate = chat.last_accessed_at ? new Date(chat.last_accessed_at * 1000) : null;
             const displayDate = lastAccessedDate ? lastAccessedDate.toLocaleDateString('zh-CN', { month: '2-digit', day: '2-digit' }) : 'N/A';

             chatItem.innerHTML = `
                <div class="font-medium text-sm text-gray-800 truncate pr-8">${title}</div>
                <div class="text-xs text-gray-500 mt-1 flex justify-between items-center">
                    <span>${displayDate}</span>
                    <button class="delete-chat-btn absolute right-2 top-1/2 p-1 rounded-full transition-all focus:outline-none z-10
                                   md:opacity-0 md:group-hover:opacity-100 text-gray-400 hover:text-red-500 hover:bg-red-100 interactive-button"
                            data-session-id="${chat.id}" aria-label="删除对话">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 pointer-events-none" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>
                    </button>
                </div>
            `;

            chatItem.addEventListener('click', () => {
                if (currentSessionId === chat.id) { if (window.innerWidth < 768 && sidebar.classList.contains('sidebar-visible')) closeSidebar(); return; }
                if (isStreaming) { showNotification('请等待当前回答完成', 2000); return; }
                loadChatSession(chat.id); // Load directly
                if (window.innerWidth < 768) closeSidebar();
            });

            const deleteBtn = chatItem.querySelector('.delete-chat-btn');
            deleteBtn.addEventListener('click', (event) => { event.stopPropagation(); handleDeleteChat(chat.id); });
            deleteBtn.addEventListener('mousemove', handleButtonMouseMove);
            chatListContainer.appendChild(chatItem);
         });
         console.log("Chat list rendered.");
    }

    const handleDeleteChat = async (sessionIdToDelete) => { // Changed: Modifies appData
         console.log(`Attempting to delete chat: ${sessionIdToDelete}`);
        if (isStreaming && currentSessionId === sessionIdToDelete) { showNotification('请等待当前对话结束后再删除', 3000); return; }

        const sessionTitle = appData.sessions[sessionIdToDelete]?.messages?.find(m => m.role === 'user')?.content?.substring(0, 20) || '此对话';
        const confirmed = await showConfirm('确认删除', `确定要删除"${sessionTitle}"吗？此操作不可恢复。`, '确认删除', '取消');

        if (confirmed) {
            console.log(`Confirmed deletion for: ${sessionIdToDelete}`);
            const wasCurrentSession = currentSessionId === sessionIdToDelete;

            // Delete from appData and save
            if (appData.sessions[sessionIdToDelete]) {
                delete appData.sessions[sessionIdToDelete];
                saveDataToLocalStorage();
                showNotification('对话已删除', 2000);
                const remainingSessions = loadChatList(); // Reload and re-render list

                if (wasCurrentSession) {
                    currentSessionId = null;
                    chatMessagesContainer.innerHTML = '';
                    initialMessage.classList.remove('hidden');
                    messageInput.value = '';
                    messageInput.disabled = true; // Disable input until a new session is loaded/created
                    sendButton.disabled = true;

                    // Automatically load the next available chat or create a new one
                    if (remainingSessions.length > 0) {
                        const nextSessionId = remainingSessions[0].id; // Load the most recent one
                        if (nextSessionId) {
                            loadChatSession(nextSessionId);
                        } else {
                            createNewChat(); // Fallback if ID is somehow invalid
                        }
                    } else {
                        createNewChat(); // Create new if no chats are left
                    }
                }
            } else {
                 console.warn(`Session ${sessionIdToDelete} not found in appData during delete.`);
                 showNotification('删除失败：未找到对话', 3000);
                 loadChatList(); // Refresh list in case of inconsistency
            }
        } else {
            console.log(`Deletion cancelled for: ${sessionIdToDelete}`);
        }
     };

    const loadChatSession = (sessionId) => { // Changed: Reads from appData
         if (isStreaming) { showNotification('请等待当前回答完成后再切换对话', 3000); return; }
         if (currentSessionId === sessionId) { console.log(`Session ${sessionId} is already active.`); if (window.innerWidth < 768 && sidebar.classList.contains('sidebar-visible')) closeSidebar(); return; }

         console.log(`Attempting to load session: ${sessionId}`);
         const sessionData = appData.sessions[sessionId];

         if (!sessionData) {
            console.error(`加载会话 ${sessionId} 失败: 未在 localStorage 中找到`);
            chatMessagesContainer.innerHTML = `<div class="p-4 m-4 bg-red-100 border border-red-300 text-red-700 rounded-lg text-center"><p class="font-semibold">加载对话失败</p><p class="text-sm mt-1">未找到该对话记录。</p></div>`;
            initialMessage.classList.add('hidden'); showNotification('加载对话失败', 3000);
            currentSessionId = null;
            loadChatList(); // Refresh list
            messageInput.disabled = true; sendButton.disabled = true;
            return;
         }

         currentSessionId = sessionId;
         chatMessagesContainer.innerHTML = ''; // Clear loading/previous messages
         const messages = sessionData.messages || [];
         console.log(`Loaded ${messages.length} messages for session ${sessionId} from localStorage.`);

         if (messages.length === 0) {
             initialMessage.classList.remove('hidden');
         } else {
             initialMessage.classList.add('hidden');
             messages.forEach(msg => {
                 if (msg && typeof msg.role === 'string' && typeof msg.content === 'string') {
                     renderMessage(msg.role, msg.content);
                 } else {
                     console.warn("Skipping invalid message object:", msg);
                 }
             });
         }

         // Update last accessed time and save
         sessionData.last_accessed_at = Math.floor(Date.now() / 1000);
         saveDataToLocalStorage();

         messageInput.disabled = false;
         sendButton.disabled = false;
         if (messageInput.offsetWidth > 0 || messageInput.offsetHeight > 0 || messageInput.getClientRects().length > 0) {
             messageInput.focus();
         }
         setTimeout(() => { chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'auto' }); }, 150);

         loadChatList(); // Refresh the list to show updated order and active state
      };

    const createNewChat = () => { // Changed: Creates entry in appData
        if (isStreaming) { showNotification('请等待当前回答完成后再新建对话', 3000); return; }
        console.log("Creating new chat in localStorage...");

        const newSessionId = generateUUID();
        const now = Math.floor(Date.now() / 1000);

        // Add to appData
        appData.sessions[newSessionId] = {
            created_at: now,
            last_accessed_at: now,
            messages: [] // Start with empty messages
        };
        saveDataToLocalStorage(); // Save the new session immediately

        console.log(`New chat created successfully in localStorage: ${newSessionId}`);
        currentSessionId = newSessionId;

        // Update UI
        chatMessagesContainer.innerHTML = '';
        initialMessage.classList.remove('hidden');
        messageInput.value = '';
        messageInput.disabled = false;
        sendButton.disabled = false;

        loadChatList(); // Refresh list to show the new chat

        if (messageInput.offsetWidth > 0 || messageInput.offsetHeight > 0 || messageInput.getClientRects().length > 0) {
            messageInput.focus();
        }
        if (window.innerWidth < 768) {
            closeSidebar();
        }
        return newSessionId; // Return the ID for potential use
    };


    // --- Form Submission ---
    chatForm.addEventListener('submit', async (e) => { // Changed: Calls DeepSeek directly
        e.preventDefault();
        if (isStreaming) { showNotification('请等待当前回答完成', 2000); return; }
        const message = messageInput.value.trim();
        if (!message) return;

        // Ensure a session exists. If not, create one.
        if (!currentSessionId || !appData.sessions[currentSessionId]) {
            console.log("No active session, creating a new one before sending.");
            const newId = createNewChat();
            if (!newId) { // Check if creation failed (shouldn't normally happen here)
                showNotification('无法创建新对话，请重试', 3000);
                return;
            }
            // Small delay to ensure UI updates before proceeding might be needed in complex scenarios, but often okay without.
        }

        console.log(`Sending message to session ${currentSessionId}: ${message.substring(0, 50)}...`);
        const userMessageContent = message;
        messageInput.value = '';
        messageInput.disabled = true;
        sendButton.disabled = true;
        isStreaming = true;
        initialMessage.classList.add('hidden');

        // --- Add user message to UI and localStorage ---
        const userMessage = { role: 'user', content: userMessageContent, timestamp: Math.floor(Date.now() / 1000) };
        appData.sessions[currentSessionId].messages.push(userMessage);
        appData.sessions[currentSessionId].last_accessed_at = userMessage.timestamp;
        saveDataToLocalStorage(); // Save user message
        renderMessage('user', userMessageContent);
        // --- ---

        const loadingIndicator = renderMessage('assistant', '', true);
        let assistantContent = '';
        let lastMessageElement = loadingIndicator;

        // --- Prepare messages for DeepSeek API ---
        const messagesForApi = appData.sessions[currentSessionId].messages.map(msg => ({
            role: msg.role,
            content: msg.content
        }));
        // --- ---

        try {
            // !!!!! WARNING: API KEY IS SENT FROM CLIENT !!!!!
            const response = await fetch(DEEPSEEK_API_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${DEEPSEEK_API_KEY}` // Key directly used here
                },
                body: JSON.stringify({
                    model: 'deepseek-chat', // Or your preferred model
                    messages: messagesForApi,
                    stream: true,
                    temperature: 0.7 // Adjust as needed
                })
            });
            // !!!!! END WARNING !!!!!

            if (!response.ok) {
                const errorText = await response.text();
                let errorDetail = `HTTP error! status: ${response.status}`;
                 try {
                    const errorJson = JSON.parse(errorText);
                    errorDetail += `: ${errorJson.error?.message || errorText}`;
                 } catch {
                    errorDetail += ` - ${errorText.substring(0, 200)}`;
                 }
                 throw new Error(errorDetail);
            }
            if (!response.body) throw new Error("Response body is missing.");

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            let doneStreaming = false;
            console.log("Starting to read stream from DeepSeek...");

            while (!doneStreaming) {
                const { done, value } = await reader.read();
                if (done) {
                    doneStreaming = true;
                    // Process any remaining buffer content if necessary (usually handled by line splitting)
                    // console.log("Stream finished reading (EOF). Final buffer:", buffer);
                    break;
                }

                buffer += decoder.decode(value, { stream: true });
                // console.log("Buffer content:", buffer); // Debugging stream data
                let boundary;
                while ((boundary = buffer.indexOf('\n\n')) !== -1) {
                    const messagePart = buffer.substring(0, boundary).trim();
                    buffer = buffer.substring(boundary + 2);
                    // console.log("Processing message part:", messagePart); // Debugging SSE parts

                    if (messagePart.startsWith('data: ')) {
                        const dataStr = messagePart.substring(6).trim();
                        if (dataStr === '[DONE]') {
                            // console.log("Received [DONE] marker.");
                            doneStreaming = true;
                            break; // Exit inner while loop
                        }
                        try {
                            const data = JSON.parse(dataStr);
                            if (data.choices && data.choices[0] && data.choices[0].delta) {
                                const contentChunk = data.choices[0].delta.content;
                                if (contentChunk) {
                                    assistantContent += contentChunk;
                                    const updatedElement = updateLoadingMessage(assistantContent);
                                    if (updatedElement) lastMessageElement = updatedElement;
                                }
                            }
                            // Check for completion flag if API provides one (DeepSeek seems to use [DONE])
                            // if (data.done) { doneStreaming = true; break; }
                        } catch (err) {
                            console.error('解析 SSE JSON 数据错误:', err, 'Data string:', dataStr);
                        }
                    } else if (messagePart) {
                        // Handle non-data lines if any (e.g., comments starting with ':')
                         console.log("Received non-data line:", messagePart);
                    }
                    if (doneStreaming) break; // Exit inner while loop if DONE was found
                }
                if (doneStreaming) break; // Exit outer while loop
            }
            console.log("Stream finished processing.");

        } catch (error) {
            console.error('调用 DeepSeek API 或处理流失败:', error);
            assistantContent += `\n\n--- \n抱歉，处理时遇到错误：${error.message || '未知 API 错误'}`;
             const errorElement = updateLoadingMessage(assistantContent); // Update message with error
            if (errorElement) lastMessageElement = errorElement;
            else renderMessage('assistant', `抱歉，处理时遇到错误：${error.message || '未知 API 错误'}`); // Render new if update failed
            showNotification(`消息处理出错: ${error.message || '未知 API 错误'}`, 4000);
        } finally {
            console.log("Stream processing finished or failed. Running finally block.");
            isStreaming = false;
            removeLoadingIndicator(); // Clean up the loading dots

            // --- Add assistant message to localStorage ---
            if (assistantContent.trim()) { // Only save if there's content
                 const assistantMessage = { role: 'assistant', content: assistantContent, timestamp: Math.floor(Date.now() / 1000) };
                 // Ensure the session still exists (it should unless deleted concurrently, which is unlikely here)
                 if (appData.sessions[currentSessionId]) {
                     appData.sessions[currentSessionId].messages.push(assistantMessage);
                     appData.sessions[currentSessionId].last_accessed_at = assistantMessage.timestamp;
                     saveDataToLocalStorage(); // Save assistant response
                 } else {
                     console.error("Current session disappeared before assistant message could be saved.");
                 }
            } else {
                console.log("Assistant produced no content, not saving assistant message.");
            }
            // --- ---

             // Re-render MathJax on the final content if needed
             const finalAssistantBubble = chatMessagesContainer.querySelector('.assistant-bubble:last-child .message-content');
             if (finalAssistantBubble && assistantContent && assistantContent.match(/(\$|\\\(|\\\[|\\begin\{)/)) {
                 requestAnimationFrame(() => {
                     if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                         MathJax.typesetPromise([finalAssistantBubble]).catch(err => console.error('Final MathJax typeset failed:', err));
                     }
                 });
             }

            // Refresh chat list to update timestamp/order
            loadChatList();

            // Re-enable input only if a valid session still exists
            if (currentSessionId && appData.sessions[currentSessionId]) {
                 messageInput.disabled = false;
                 sendButton.disabled = false;
                 if (messageInput.offsetWidth > 0 || messageInput.offsetHeight > 0 || messageInput.getClientRects().length > 0) {
                     messageInput.focus();
                 }
            } else {
                 messageInput.disabled = true;
                 sendButton.disabled = true;
                 console.warn("Input remains disabled as currentSessionId is invalid after streaming/error.");
            }
        }
    });

    // --- Button Mouse Interaction (No change needed) ---
    function handleButtonMouseMove(event) { /* ... same as before ... */ const target = event.currentTarget; const rect = target.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; target.style.setProperty('--mouse-x', `${(x / target.offsetWidth) * 100}%`); target.style.setProperty('--mouse-y', `${(y / target.offsetHeight) * 100}%`); }

    // --- Event Listeners (No change needed) ---
    mobileMenuBtn.addEventListener('click', toggleSidebar);
    closeSidebarBtn.addEventListener('click', closeSidebar);
    newChatBtn.addEventListener('click', createNewChat); // Connect button to new client-side function
    mobileMenuBtn.addEventListener('mousemove', handleButtonMouseMove);
    closeSidebarBtn.addEventListener('mousemove', handleButtonMouseMove);
    newChatBtn.addEventListener('mousemove', handleButtonMouseMove);
    sendButton.addEventListener('mousemove', handleButtonMouseMove);

    document.addEventListener('click', (event) => { /* ... same as before ... */ if (window.innerWidth < 768 && sidebar.classList.contains('sidebar-visible')) { const isClickInsideSidebar = sidebar.contains(event.target); const isClickOnMenuButton = mobileMenuBtn.contains(event.target); const isClickInsideConfirm = confirmModal.contains(event.target) && !confirmModal.classList.contains('hidden'); if (!isClickInsideSidebar && !isClickOnMenuButton && !isClickInsideConfirm) { closeSidebar(); } } });

    window.addEventListener('resize', () => { /* ... same as before ... */ const isMobile = window.innerWidth < 768; if (!isMobile) { sidebar.classList.remove('sidebar-visible', 'sidebar-mobile'); isSidebarAnimating = false; } else { if (!sidebar.classList.contains('sidebar-visible') && !sidebar.classList.contains('sidebar-mobile')) { sidebar.classList.add('sidebar-mobile'); } if (sidebar.classList.contains('sidebar-visible')) { mobileMenuBtn.classList.add('btn-hidden'); } else { mobileMenuBtn.classList.remove('btn-hidden'); } } });

    // --- Initialize App ---
    const initializeApp = () => {
        console.log("Initializing application (Client-Side Storage)...");
        console.warn("SECURITY WARNING: API Key is embedded in the source code. Do not use this publicly.");

        window.dispatchEvent(new Event('resize')); // Set initial sidebar state
        messageInput.disabled = true; // Start disabled
        sendButton.disabled = true;
        initialMessage.classList.remove('hidden');

        loadDataFromLocalStorage(); // Load existing data
        const existingSessions = loadChatList(); // Load and render the list

        if (existingSessions.length > 0) {
            const latestSessionId = existingSessions[0].id; // Load the most recent session
            console.log(`Found ${existingSessions.length} chats, loading latest: ${latestSessionId}`);
            loadChatSession(latestSessionId);
        } else {
            console.log("No existing chats found, creating a new one.");
            createNewChat(); // Create initial chat if none exist
        }

        // Final check on input state
        if (currentSessionId && appData.sessions[currentSessionId]) {
            messageInput.disabled = false;
            sendButton.disabled = false;
            if (messageInput.offsetWidth > 0 || messageInput.offsetHeight > 0 || messageInput.getClientRects().length > 0) {
                messageInput.focus();
            }
            console.log("Initialization complete, input enabled.");
        } else {
            messageInput.disabled = true;
            sendButton.disabled = true;
            console.log("Initialization ended without a valid session, input remains disabled.");
            if (chatMessagesContainer.children.length === 0) {
                initialMessage.classList.remove('hidden');
            }
        }
         requestAnimationFrame(() => window.dispatchEvent(new Event('resize')));
         console.log("Application initialized.");
    };

    // Start App
    initializeApp();
</script>
</body>
</html>